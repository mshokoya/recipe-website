Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _Img = require('./Img');

var _Img2 = _interopRequireDefault(_Img);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

if (typeof window !== 'undefined') {
  require('intersection-observer');
}

// Cache if we've intersected an image before so we don't
// lazy-load & fade in on subsequent mounts.
var imageCache = {};
var inImageCache = function inImageCache(_ref, shouldCache) {
  var handle = _ref.handle;

  if (imageCache[handle]) {
    return true;
  }
  if (shouldCache) {
    imageCache[handle] = true;
  }
  return false;
};

// check webp support
var isWebpSupportedCache = null;
var isWebpSupported = function isWebpSupported() {
  if (isWebpSupportedCache !== null) {
    return isWebpSupportedCache;
  }

  var elem = typeof window !== 'undefined' ? window.document.createElement('canvas') : {};
  if (elem.getContext && elem.getContext('2d')) {
    isWebpSupportedCache = elem.toDataURL('image/webp').indexOf('data:image/webp') === 0;
    return isWebpSupportedCache;
  }
  return false;
};

// Add IntersectionObserver to component
var listeners = [];
var io = void 0;
var getIO = function getIO() {
  if (typeof io === 'undefined' && typeof window !== 'undefined') {
    io = new IntersectionObserver(function (entries) {
      entries.forEach(function (entry) {
        listeners.forEach(function (listener) {
          if (listener[0] === entry.target) {
            // Edge doesn't currently support isIntersecting, so also test for an intersectionRatio > 0
            if (entry.isIntersecting || entry.intersectionRatio > 0) {
              // when we intersect we cache the intersecting image for subsequent mounts
              io.unobserve(listener[0]);
              listener[1]();
            }
          }
        });
      });
    }, { rootMargin: '200px' });
  }

  return io;
};
var listenToIntersections = function listenToIntersections(element, callback) {
  getIO().observe(element);
  listeners.push([element, callback]);
};

var bgColor = function bgColor(backgroundColor) {
  return typeof backgroundColor === 'boolean' ? 'lightgray' : backgroundColor;
};

// We always keep the resize transform to have matching sizes + aspect ratio
// If used with native height & width from GraphCMS it produces no transform
var resizeImage = function resizeImage(_ref2) {
  var width = _ref2.width,
      height = _ref2.height,
      fit = _ref2.fit;
  return 'resize=w:' + String(width) + ',h:' + String(height) + ',fit:' + String(fit);
};

var compressAndWebp = function compressAndWebp(webp) {
  return (webp ? 'output=format:webp/' : '') + 'compress';
};

var constructURL = function constructURL(handle, withWebp, baseURI) {
  return function (resize) {
    return function (transforms) {
      return [baseURI, resize].concat(_toConsumableArray(transforms), [compressAndWebp(isWebpSupported() && withWebp), handle]).join('/');
    };
  };
};

// responsiveness transforms
var responsiveSizes = function responsiveSizes(size) {
  return [size / 4, size / 2, size, size * 1.5, size * 2, size * 3];
};

var getWidths = function getWidths(width, maxWidth) {
  var sizes = responsiveSizes(maxWidth).filter(function (size) {
    return size < width;
  });
  // Add the original width to ensure the largest image possible
  // is available for small images.
  var finalSizes = [].concat(_toConsumableArray(sizes), [width]);
  return finalSizes;
};

var srcSet = function srcSet(srcBase, srcWidths, fit, transforms) {
  return srcWidths.map(function (width) {
    return String(srcBase(['resize=w:' + String(Math.floor(width)) + ',fit:' + String(fit)])(transforms)) + ' ' + String(Math.floor(width)) + 'w';
  }).join(',\n');
};

var imgSizes = function imgSizes(maxWidth) {
  return '(max-width: ' + String(maxWidth) + 'px) 100vw, ' + String(maxWidth) + 'px';
};

var GraphImage = function (_React$Component) {
  _inherits(GraphImage, _React$Component);

  function GraphImage(props) {
    _classCallCheck(this, GraphImage);

    var _this = _possibleConstructorReturn(this, (GraphImage.__proto__ || Object.getPrototypeOf(GraphImage)).call(this, props));

    var isVisible = true;
    var imgLoaded = true;
    var IOSupported = false;

    var seenBefore = inImageCache(props);

    if (!seenBefore && typeof window !== 'undefined' && window.IntersectionObserver) {
      isVisible = false;
      imgLoaded = false;
      IOSupported = true;
    }

    // Never render image while server rendering
    if (typeof window === 'undefined') {
      isVisible = false;
      imgLoaded = false;
    }

    _this.state = {
      isVisible: isVisible,
      imgLoaded: imgLoaded,
      IOSupported: IOSupported
    };

    _this.handleRef = _this.handleRef.bind(_this);
    _this.onImageLoaded = _this.onImageLoaded.bind(_this);
    return _this;
  }

  _createClass(GraphImage, [{
    key: 'onImageLoaded',
    value: function () {
      function onImageLoaded() {
        var _this2 = this;

        if (this.state.IOSupported) {
          this.setState(function () {
            return {
              imgLoaded: true
            };
          }, function () {
            inImageCache(_this2.props.image, true);
          });
        }
        if (this.props.onLoad) {
          this.props.onLoad();
        }
      }

      return onImageLoaded;
    }()
  }, {
    key: 'handleRef',
    value: function () {
      function handleRef(ref) {
        var _this3 = this;

        if (this.state.IOSupported && ref) {
          listenToIntersections(ref, function () {
            _this3.setState({ isVisible: true, imgLoaded: false });
          });
        }
      }

      return handleRef;
    }()
  }, {
    key: 'render',
    value: function () {
      function render() {
        var _props = this.props,
            title = _props.title,
            alt = _props.alt,
            className = _props.className,
            outerWrapperClassName = _props.outerWrapperClassName,
            style = _props.style,
            _props$image = _props.image,
            width = _props$image.width,
            height = _props$image.height,
            handle = _props$image.handle,
            fit = _props.fit,
            maxWidth = _props.maxWidth,
            withWebp = _props.withWebp,
            transforms = _props.transforms,
            blurryPlaceholder = _props.blurryPlaceholder,
            backgroundColor = _props.backgroundColor,
            fadeIn = _props.fadeIn,
            baseURI = _props.baseURI;


        if (width && height && handle) {
          // unify after webp + blur resolved
          var srcBase = constructURL(handle, withWebp, baseURI);
          var thumbBase = constructURL(handle, false, baseURI);

          // construct the final image url
          var sizedSrc = srcBase(resizeImage({ width: width, height: height, fit: fit }));
          var finalSrc = sizedSrc(transforms);

          // construct blurry placeholder url
          var thumbSize = { width: 20, height: 20, fit: 'crop' };
          var thumbSrc = thumbBase(resizeImage(thumbSize))(['blur=amount:2']);

          // construct srcSet if maxWidth provided
          var srcSetImgs = srcSet(srcBase, getWidths(width, maxWidth), fit, transforms);
          var sizes = imgSizes(maxWidth);

          // The outer div is necessary to reset the z-index to 0.
          return _react2['default'].createElement(
            'div',
            {
              className: String(outerWrapperClassName) + ' graphcms-image-outer-wrapper',
              style: {
                zIndex: 0,
                // Let users set component to be absolutely positioned.
                position: style.position === 'absolute' ? 'initial' : 'relative'
              }
            },
            _react2['default'].createElement(
              'div',
              {
                className: String(className) + ' graphcms-image-wrapper',
                style: Object.assign({
                  position: 'relative',
                  overflow: 'hidden',
                  zIndex: 1
                }, style),
                ref: this.handleRef
              },
              _react2['default'].createElement('div', {
                style: {
                  width: '100%',
                  paddingBottom: 100 / (width / height) + '%'
                }
              }),
              blurryPlaceholder && _react2['default'].createElement(_Img2['default'], {
                alt: alt,
                title: title,
                src: thumbSrc,
                opacity: this.state.imgLoaded ? 0 : 1,
                transitionDelay: '0.25s'
              }),
              backgroundColor && _react2['default'].createElement('div', {
                title: title,
                style: {
                  backgroundColor: bgColor(backgroundColor),
                  position: 'absolute',
                  top: 0,
                  bottom: 0,
                  opacity: this.state.imgLoaded ? 0 : 1,
                  transitionDelay: '0.25s',
                  right: 0,
                  left: 0
                }
              }),
              this.state.isVisible && _react2['default'].createElement(_Img2['default'], {
                alt: alt,
                title: title,
                srcSet: srcSetImgs,
                src: finalSrc,
                sizes: sizes,
                opacity: this.state.imgLoaded || !fadeIn ? 1 : 0,
                onLoad: this.onImageLoaded
              })
            )
          );
        }

        return null;
      }

      return render;
    }()
  }]);

  return GraphImage;
}(_react2['default'].Component);

GraphImage.defaultProps = {
  title: '',
  alt: '',
  className: '',
  outerWrapperClassName: '',
  style: {},
  fit: 'crop',
  maxWidth: 800,
  withWebp: true,
  transforms: [],
  blurryPlaceholder: true,
  backgroundColor: '',
  fadeIn: true,
  onLoad: null,
  baseURI: 'https://media.graphcms.com'
};

GraphImage.propTypes = {
  title: _propTypes2['default'].string,
  alt: _propTypes2['default'].string,
  // Support Glamor's css prop for classname
  className: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].object]),
  outerWrapperClassName: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].object]),
  style: _propTypes2['default'].object,
  image: _propTypes2['default'].shape({
    handle: _propTypes2['default'].string,
    height: _propTypes2['default'].number,
    width: _propTypes2['default'].number
  }).isRequired,
  fit: _propTypes2['default'].oneOf(['clip', 'crop', 'scale', 'max']),
  maxWidth: _propTypes2['default'].number,
  withWebp: _propTypes2['default'].bool,
  transforms: _propTypes2['default'].arrayOf(_propTypes2['default'].string),
  onLoad: _propTypes2['default'].func,
  blurryPlaceholder: _propTypes2['default'].bool,
  backgroundColor: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].bool]),
  fadeIn: _propTypes2['default'].bool,
  baseURI: _propTypes2['default'].string
};

exports['default'] = GraphImage;